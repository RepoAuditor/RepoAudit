[
    {
        "Function Path": "<            subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */, main>",
        "Path": "<Lines: 310, 312, 314, 320-321, Source: `            subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */`,  Function: `main`, Status: Bug. File: ../benchmark/C/memcached/memcached.c>",
        "Explanation": "The pointer `subopts_orig` at line 310 is not freed before the function returns at line 321.",
        "Model": "Claude-3.5, Deepseek-R1",
        "Is Reproduce": "No",
        "Functions": [
            {
                "Function": "main",
                "Function Body": "int main (int argc, char **argv) {\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    bool preallocate = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char *buf;\n    char unit = '\\0';\n    int size_max = 0;\n    int retval = EXIT_SUCCESS;\n    \n    static int *l_socket = NULL;\n\n    \n    static int *u_socket = NULL;\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n    bool start_lru_maintainer = false;\n    bool start_lru_crawler = false;\n    enum hashfunc_type hash_type = JENKINS_HASH;\n    uint32_t tocrawl;\n\n    char *subopts, *subopts_orig;\n    char *subopts_value;\n    enum {\n        MAXCONNS_FAST = 0,\n        HASHPOWER_INIT,\n        SLAB_REASSIGN,\n        SLAB_AUTOMOVE,\n        TAIL_REPAIR_TIME,\n        HASH_ALGORITHM,\n        LRU_CRAWLER,\n        LRU_CRAWLER_SLEEP,\n        LRU_CRAWLER_TOCRAWL,\n        LRU_MAINTAINER,\n        HOT_LRU_PCT,\n        WARM_LRU_PCT,\n        NOEXP_NOEVICT\n    };\n    char *const subopts_tokens[] = {\n        [MAXCONNS_FAST] = \"maxconns_fast\",\n        [HASHPOWER_INIT] = \"hashpower\",\n        [SLAB_REASSIGN] = \"slab_reassign\",\n        [SLAB_AUTOMOVE] = \"slab_automove\",\n        [TAIL_REPAIR_TIME] = \"tail_repair_time\",\n        [HASH_ALGORITHM] = \"hash_algorithm\",\n        [LRU_CRAWLER] = \"lru_crawler\",\n        [LRU_CRAWLER_SLEEP] = \"lru_crawler_sleep\",\n        [LRU_CRAWLER_TOCRAWL] = \"lru_crawler_tocrawl\",\n        [LRU_MAINTAINER] = \"lru_maintainer\",\n        [HOT_LRU_PCT] = \"hot_lru_pct\",\n        [WARM_LRU_PCT] = \"warm_lru_pct\",\n        [NOEXP_NOEVICT] = \"expirezero_does_not_evict\",\n        NULL\n    };\n\n    if (!sanitycheck()) {\n        return EX_OSERR;\n    }\n\n    \n    signal(SIGINT, sig_handler);\n    signal(SIGTERM, sig_handler);\n\n    \n    settings_init();\n\n    \n    init_lru_crawler();\n    init_lru_maintainer();\n\n    \n    setbuf(stderr, NULL);\n\n    \n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  \n          \"A\"  \n          \"p:\"  \n          \"s:\"  \n          \"U:\"  \n          \"m:\"  \n          \"M\"   \n          \"c:\"  \n          \"k\"   \n          \"hiV\" \n          \"r\"   \n          \"v\"   \n          \"d\"   \n          \"l:\"  \n          \"u:\"  \n          \"P:\"  \n          \"f:\"  \n          \"n:\"  \n          \"t:\"  \n          \"D:\"  \n          \"L\"   \n          \"R:\"  \n          \"C\"   \n          \"b:\"  \n          \"B:\"  \n          \"I:\"  \n          \"S\"   \n          \"F\"   \n          \"o:\"  \n        ))) {\n        switch (c) {\n        case 'A':\n            \n            settings.shutdown_command = true;\n            break;\n\n        case 'a':\n            \n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n            break;\n        case 'M':\n            settings.evict_to_free = 0;\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            if (settings.maxconns <= 0) {\n                fprintf(stderr, \"Maximum connections must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'V':\n            printf(PACKAGE \" \" VERSION \"\\n\");\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                if (strstr(settings.inter, optarg) != NULL) {\n                    break;\n                }\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    fprintf(stderr, \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event == 0) {\n                fprintf(stderr, \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                fprintf(stderr, \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n            break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                fprintf(stderr, \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                fprintf(stderr, \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            \n\n\n\n            if (settings.num_threads > 64) {\n                fprintf(stderr, \"WARNING: Setting a high number of worker\"\n                                \"threads is not recommended.\\n\"\n                                \" Set this value to the number of cores in\"\n                                \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            if (! optarg || ! optarg[0]) {\n                fprintf(stderr, \"No delimiter specified\\n\");\n                return 1;\n            }\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                preallocate = true;\n            } else {\n                fprintf(stderr, \"Cannot enable large pages on this system\\n\"\n                    \"(There is no Linux support as of this version)\\n\");\n                return 1;\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                fprintf(stderr, \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            buf = strdup(optarg);\n            unit = buf[strlen(buf)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                buf[strlen(buf)-1] = '\\0';\n                size_max = atoi(buf);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(buf);\n            }\n            free(buf);\n            if (settings.item_size_max < 1024) {\n                fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                fprintf(stderr, \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                fprintf(stderr, \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n            break;\n        case 'S': \n#ifndef ENABLE_SASL\n            fprintf(stderr, \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#endif\n            settings.sasl = true;\n            break;\n       case 'F' :\n            settings.flush_enabled = false;\n            break;\n        case 'o': \n            subopts_orig = subopts = strdup(optarg); \n\n            while (*subopts != '\\0') {\n\n            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {\n            case MAXCONNS_FAST:\n                settings.maxconns_fast = true;\n                break;\n            case HASHPOWER_INIT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for hashpower\\n\");\n                    return 1;\n                }\n                settings.hashpower_init = atoi(subopts_value);\n                if (settings.hashpower_init < 12) {\n                    fprintf(stderr, \"Initial hashtable multiplier of %d is too low\\n\",\n                        settings.hashpower_init);\n                    return 1;\n                } else if (settings.hashpower_init > 64) {\n                    fprintf(stderr, \"Initial hashtable multiplier of %d is too high\\n\"\n                        \"Choose a value based on \\\"STAT hash_power_level\\\" from a running instance\\n\",\n                        settings.hashpower_init);\n                    return 1;\n                }\n                break;\n            case SLAB_REASSIGN:\n                settings.slab_reassign = true;\n                break;\n            case SLAB_AUTOMOVE:\n                if (subopts_value == NULL) {\n                    settings.slab_automove = 1;\n                    break;\n                }\n                settings.slab_automove = atoi(subopts_value);\n                if (settings.slab_automove < 0 || settings.slab_automove > 2) {\n                    fprintf(stderr, \"slab_automove must be between 0 and 2\\n\");\n                    return 1;\n                }\n                break;\n            case TAIL_REPAIR_TIME:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for tail_repair_time\\n\");\n                    return 1;\n                }\n                settings.tail_repair_time = atoi(subopts_value);\n                if (settings.tail_repair_time < 10) {\n                    fprintf(stderr, \"Cannot set tail_repair_time to less than 10 seconds\\n\");\n                    return 1;\n                }\n                break;\n            case HASH_ALGORITHM:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hash_algorithm argument\\n\");\n                    return 1;\n                };\n                if (strcmp(subopts_value, \"jenkins\") == 0) {\n                    hash_type = JENKINS_HASH;\n                } else if (strcmp(subopts_value, \"murmur3\") == 0) {\n                    hash_type = MURMUR3_HASH;\n                } else {\n                    fprintf(stderr, \"Unknown hash_algorithm option (jenkins, murmur3)\\n\");\n                    return 1;\n                }\n                break;\n            case LRU_CRAWLER:\n                start_lru_crawler = true;\n                break;\n            case LRU_CRAWLER_SLEEP:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing lru_crawler_sleep value\\n\");\n                    return 1;\n                }\n                settings.lru_crawler_sleep = atoi(subopts_value);\n                if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {\n                    fprintf(stderr, \"LRU crawler sleep must be between 0 and 1 second\\n\");\n                    return 1;\n                }\n                break;\n            case LRU_CRAWLER_TOCRAWL:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing lru_crawler_tocrawl value\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &tocrawl)) {\n                    fprintf(stderr, \"lru_crawler_tocrawl takes a numeric 32bit value\\n\");\n                    return 1;\n                }\n                settings.lru_crawler_tocrawl = tocrawl;\n                break;\n            case LRU_MAINTAINER:\n                start_lru_maintainer = true;\n                break;\n            case HOT_LRU_PCT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hot_lru_pct argument\\n\");\n                    return 1;\n                };\n                settings.hot_lru_pct = atoi(subopts_value);\n                if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {\n                    fprintf(stderr, \"hot_lru_pct must be > 1 and < 80\\n\");\n                    return 1;\n                }\n                break;\n            case WARM_LRU_PCT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing warm_lru_pct argument\\n\");\n                    return 1;\n                };\n                settings.warm_lru_pct = atoi(subopts_value);\n                if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {\n                    fprintf(stderr, \"warm_lru_pct must be > 1 and < 80\\n\");\n                    return 1;\n                }\n                break;\n            case NOEXP_NOEVICT:\n                settings.expirezero_does_not_evict = true;\n                break;\n            default:\n                printf(\"Illegal suboption \\\"%s\\\"\\n\", subopts_value);\n                return 1;\n            }\n\n            }\n            free(subopts_orig);\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    if (settings.lru_maintainer_thread && settings.hot_lru_pct + settings.warm_lru_pct > 80) {\n        fprintf(stderr, \"hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\\n\");\n        exit(EX_USAGE);\n    }\n\n    if (hash_init(hash_type) != 0) {\n        fprintf(stderr, \"Failed to initialize hash_algorithm!\\n\");\n        exit(EX_USAGE);\n    }\n\n    \n\n\n\n    if (settings.inter != NULL && strchr(settings.inter, ',')) {\n        settings.num_threads_per_udp = 1;\n    } else {\n        settings.num_threads_per_udp = settings.num_threads;\n    }\n\n    if (settings.sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol != binary_prot) {\n                fprintf(stderr, \"ERROR: You cannot allow the ASCII protocol while using SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (tcp_specified && !udp_specified) {\n        settings.udpport = settings.port;\n    } else if (udp_specified && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        \n\n\n\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                \n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        \n\n\n\n\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            fprintf(stderr, \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    \n\n\n\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        fprintf(stderr, \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        rlim.rlim_cur = settings.maxconns;\n        rlim.rlim_max = settings.maxconns;\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            fprintf(stderr, \"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    \n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            fprintf(stderr, \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            fprintf(stderr, \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            fprintf(stderr, \"failed to assume identity of user %s\\n\", username);\n            exit(EX_OSERR);\n        }\n    }\n\n    \n    if (settings.sasl) {\n        init_sasl();\n    }\n\n    \n    \n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            perror(\"Failed to ignore SIGHUP\");\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n            fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    \n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            fprintf(stderr, \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    \n    main_base = event_init();\n\n    \n    stats_init();\n    assoc_init(settings.hashpower_init);\n    conn_init();\n    slabs_init(settings.maxbytes, settings.factor, preallocate);\n\n    \n\n\n\n    if (sigignore(SIGPIPE) == -1) {\n        perror(\"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n    \n    memcached_thread_init(settings.num_threads, main_base);\n\n    if (start_assoc_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    if (start_lru_crawler && start_item_crawler_thread() != 0) {\n        fprintf(stderr, \"Failed to enable LRU crawler thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (start_lru_maintainer && start_lru_maintainer_thread() != 0) {\n        fprintf(stderr, \"Failed to enable LRU maintainer thread\\n\");\n        return 1;\n    }\n\n    if (settings.slab_reassign &&\n        start_slab_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    \n    clock_handler(0, 0, 0);\n\n    \n    if (settings.socketpath != NULL) {\n        errno = 0;\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\n            exit(EX_OSERR);\n        }\n    }\n\n    \n    if (settings.socketpath == NULL) {\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char *temp_portnumber_filename = NULL;\n        size_t len;\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            len = strlen(portnumber_filename)+4+1;\n            temp_portnumber_filename = malloc(len);\n            snprintf(temp_portnumber_filename,\n                     len,\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        errno = 0;\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                           portnumber_file)) {\n            vperror(\"failed to listen on TCP port %d\", settings.port);\n            exit(EX_OSERR);\n        }\n\n        \n\n\n\n\n\n\n        \n        errno = 0;\n        if (settings.udpport && server_sockets(settings.udpport, udp_transport,\n                                              portnumber_file)) {\n            vperror(\"failed to listen on UDP port %d\", settings.udpport);\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n            free(temp_portnumber_filename);\n        }\n    }\n\n    \n\n\n    usleep(1000);\n    if (stats.curr_conns + stats.reserved_fds >= settings.maxconns - 1) {\n        fprintf(stderr, \"Maxconns setting is too low, use -c to increase.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    \n    drop_privileges();\n\n    \n    if (event_base_loop(main_base, 0) != 0) {\n        retval = EXIT_FAILURE;\n    }\n\n    stop_assoc_maintenance_thread();\n\n    \n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    \n    if (settings.inter)\n      free(settings.inter);\n    if (l_socket)\n      free(l_socket);\n    if (u_socket)\n      free(u_socket);\n\n    return retval;\n}"
            }
        ],
        "Links": [
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/memcached.c#L5416"
        ]
    },
    {
        "Function Path": "<        char *list = strdup(settings.inter);, server_sockets>",
        "Path": "<Lines: 9-10, 15-17, 21-28, Source: `        char *list = strdup(settings.inter);`,  Function: `server_sockets`, Status: Bug. File: ../benchmark/C/memcached/memcached.c>",
        "Explanation": "The pointer `list` at line 9 is not freed before the function returns at line 27 when encountering invalid IPv6 address.",
        "Model": "Claude-3.5, Deepseek-R1",
        "Is Reproduce": "Yes",
        "Functions": [
            {
                "Function": "server_sockets",
                "Function Body": "static int server_sockets(int port, enum network_transport transport,\n                          FILE *portnumber_file) {\n    if (settings.inter == NULL) {\n        return server_socket(settings.inter, port, transport, portnumber_file);\n    } else {\n        \n        char *b;\n        int ret = 0;\n        char *list = strdup(settings.inter);\n\n        if (list == NULL) {\n            fprintf(stderr, \"Failed to allocate memory for parsing server interface string\\n\");\n            return 1;\n        }\n        for (char *p = strtok_r(list, \";,\", &b);\n             p != NULL;\n             p = strtok_r(NULL, \";,\", &b)) {\n            int the_port = port;\n\n            char *h = NULL;\n            if (*p == '[') {\n                \n                \n                char *e = strchr(p, ']');\n                if (e == NULL) {\n                    fprintf(stderr, \"Invalid IPV6 address: \\\"%s\\\"\", p);\n                    return 1;\n                }\n                h = ++p; \n                *e = '\\0';\n                p = ++e; \n            }\n\n            char *s = strchr(p, ':');\n            if (s != NULL) {\n                \n                \n                \n                \n                if (strchr(s + 1, ':') == NULL || h != NULL) {\n                    *s = '\\0';\n                    ++s;\n                    if (!safe_strtol(s, &the_port)) {\n                        fprintf(stderr, \"Invalid port number: \\\"%s\\\"\", s);\n                        return 1;\n                    }\n                }\n            }\n\n            if (h != NULL)\n                p = h;\n\n            if (strcmp(p, \"*\") == 0) {\n                p = NULL;\n            }\n            ret |= server_socket(p, the_port, transport, portnumber_file);\n        }\n        free(list);\n        return ret;\n    }\n}"
            }
        ],
        "Links": [
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/memcached.c#L4629"
        ]
    },
    {
        "Function Path": "<            temp_portnumber_filename = malloc(len);, main>",
        "Path": "<Lines: 620-627, 628-632, 633-636, Source: `            temp_portnumber_filename = malloc(len);`,  Function: `main`, Status: Bug. File: ../benchmark/C/memcached/memcached.c>",
        "Explanation": "The pointer `temp_portnumber_filename` at line 627 is not freed and not propagated to any function when `portnumber_file == NULL`.",
        "Model": "Claude-3.5, Deepseek-R1",
        "Is Reproduce": "No",
        "Functions": [
            {
                "Function": "main",
                "Function Body": "int main (int argc, char **argv) {\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    bool preallocate = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char *buf;\n    char unit = '\\0';\n    int size_max = 0;\n    int retval = EXIT_SUCCESS;\n    \n    static int *l_socket = NULL;\n\n    \n    static int *u_socket = NULL;\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n    bool start_lru_maintainer = false;\n    bool start_lru_crawler = false;\n    enum hashfunc_type hash_type = JENKINS_HASH;\n    uint32_t tocrawl;\n\n    char *subopts, *subopts_orig;\n    char *subopts_value;\n    enum {\n        MAXCONNS_FAST = 0,\n        HASHPOWER_INIT,\n        SLAB_REASSIGN,\n        SLAB_AUTOMOVE,\n        TAIL_REPAIR_TIME,\n        HASH_ALGORITHM,\n        LRU_CRAWLER,\n        LRU_CRAWLER_SLEEP,\n        LRU_CRAWLER_TOCRAWL,\n        LRU_MAINTAINER,\n        HOT_LRU_PCT,\n        WARM_LRU_PCT,\n        NOEXP_NOEVICT\n    };\n    char *const subopts_tokens[] = {\n        [MAXCONNS_FAST] = \"maxconns_fast\",\n        [HASHPOWER_INIT] = \"hashpower\",\n        [SLAB_REASSIGN] = \"slab_reassign\",\n        [SLAB_AUTOMOVE] = \"slab_automove\",\n        [TAIL_REPAIR_TIME] = \"tail_repair_time\",\n        [HASH_ALGORITHM] = \"hash_algorithm\",\n        [LRU_CRAWLER] = \"lru_crawler\",\n        [LRU_CRAWLER_SLEEP] = \"lru_crawler_sleep\",\n        [LRU_CRAWLER_TOCRAWL] = \"lru_crawler_tocrawl\",\n        [LRU_MAINTAINER] = \"lru_maintainer\",\n        [HOT_LRU_PCT] = \"hot_lru_pct\",\n        [WARM_LRU_PCT] = \"warm_lru_pct\",\n        [NOEXP_NOEVICT] = \"expirezero_does_not_evict\",\n        NULL\n    };\n\n    if (!sanitycheck()) {\n        return EX_OSERR;\n    }\n\n    \n    signal(SIGINT, sig_handler);\n    signal(SIGTERM, sig_handler);\n\n    \n    settings_init();\n\n    \n    init_lru_crawler();\n    init_lru_maintainer();\n\n    \n    setbuf(stderr, NULL);\n\n    \n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  \n          \"A\"  \n          \"p:\"  \n          \"s:\"  \n          \"U:\"  \n          \"m:\"  \n          \"M\"   \n          \"c:\"  \n          \"k\"   \n          \"hiV\" \n          \"r\"   \n          \"v\"   \n          \"d\"   \n          \"l:\"  \n          \"u:\"  \n          \"P:\"  \n          \"f:\"  \n          \"n:\"  \n          \"t:\"  \n          \"D:\"  \n          \"L\"   \n          \"R:\"  \n          \"C\"   \n          \"b:\"  \n          \"B:\"  \n          \"I:\"  \n          \"S\"   \n          \"F\"   \n          \"o:\"  \n        ))) {\n        switch (c) {\n        case 'A':\n            \n            settings.shutdown_command = true;\n            break;\n\n        case 'a':\n            \n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n            break;\n        case 'M':\n            settings.evict_to_free = 0;\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            if (settings.maxconns <= 0) {\n                fprintf(stderr, \"Maximum connections must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'V':\n            printf(PACKAGE \" \" VERSION \"\\n\");\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                if (strstr(settings.inter, optarg) != NULL) {\n                    break;\n                }\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    fprintf(stderr, \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event == 0) {\n                fprintf(stderr, \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                fprintf(stderr, \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n            break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                fprintf(stderr, \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                fprintf(stderr, \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            \n\n\n\n            if (settings.num_threads > 64) {\n                fprintf(stderr, \"WARNING: Setting a high number of worker\"\n                                \"threads is not recommended.\\n\"\n                                \" Set this value to the number of cores in\"\n                                \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            if (! optarg || ! optarg[0]) {\n                fprintf(stderr, \"No delimiter specified\\n\");\n                return 1;\n            }\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                preallocate = true;\n            } else {\n                fprintf(stderr, \"Cannot enable large pages on this system\\n\"\n                    \"(There is no Linux support as of this version)\\n\");\n                return 1;\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                fprintf(stderr, \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            buf = strdup(optarg);\n            unit = buf[strlen(buf)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                buf[strlen(buf)-1] = '\\0';\n                size_max = atoi(buf);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(buf);\n            }\n            free(buf);\n            if (settings.item_size_max < 1024) {\n                fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                fprintf(stderr, \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                fprintf(stderr, \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n            break;\n        case 'S': \n#ifndef ENABLE_SASL\n            fprintf(stderr, \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#endif\n            settings.sasl = true;\n            break;\n       case 'F' :\n            settings.flush_enabled = false;\n            break;\n        case 'o': \n            subopts_orig = subopts = strdup(optarg); \n\n            while (*subopts != '\\0') {\n\n            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {\n            case MAXCONNS_FAST:\n                settings.maxconns_fast = true;\n                break;\n            case HASHPOWER_INIT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for hashpower\\n\");\n                    return 1;\n                }\n                settings.hashpower_init = atoi(subopts_value);\n                if (settings.hashpower_init < 12) {\n                    fprintf(stderr, \"Initial hashtable multiplier of %d is too low\\n\",\n                        settings.hashpower_init);\n                    return 1;\n                } else if (settings.hashpower_init > 64) {\n                    fprintf(stderr, \"Initial hashtable multiplier of %d is too high\\n\"\n                        \"Choose a value based on \\\"STAT hash_power_level\\\" from a running instance\\n\",\n                        settings.hashpower_init);\n                    return 1;\n                }\n                break;\n            case SLAB_REASSIGN:\n                settings.slab_reassign = true;\n                break;\n            case SLAB_AUTOMOVE:\n                if (subopts_value == NULL) {\n                    settings.slab_automove = 1;\n                    break;\n                }\n                settings.slab_automove = atoi(subopts_value);\n                if (settings.slab_automove < 0 || settings.slab_automove > 2) {\n                    fprintf(stderr, \"slab_automove must be between 0 and 2\\n\");\n                    return 1;\n                }\n                break;\n            case TAIL_REPAIR_TIME:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing numeric argument for tail_repair_time\\n\");\n                    return 1;\n                }\n                settings.tail_repair_time = atoi(subopts_value);\n                if (settings.tail_repair_time < 10) {\n                    fprintf(stderr, \"Cannot set tail_repair_time to less than 10 seconds\\n\");\n                    return 1;\n                }\n                break;\n            case HASH_ALGORITHM:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hash_algorithm argument\\n\");\n                    return 1;\n                };\n                if (strcmp(subopts_value, \"jenkins\") == 0) {\n                    hash_type = JENKINS_HASH;\n                } else if (strcmp(subopts_value, \"murmur3\") == 0) {\n                    hash_type = MURMUR3_HASH;\n                } else {\n                    fprintf(stderr, \"Unknown hash_algorithm option (jenkins, murmur3)\\n\");\n                    return 1;\n                }\n                break;\n            case LRU_CRAWLER:\n                start_lru_crawler = true;\n                break;\n            case LRU_CRAWLER_SLEEP:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing lru_crawler_sleep value\\n\");\n                    return 1;\n                }\n                settings.lru_crawler_sleep = atoi(subopts_value);\n                if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {\n                    fprintf(stderr, \"LRU crawler sleep must be between 0 and 1 second\\n\");\n                    return 1;\n                }\n                break;\n            case LRU_CRAWLER_TOCRAWL:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing lru_crawler_tocrawl value\\n\");\n                    return 1;\n                }\n                if (!safe_strtoul(subopts_value, &tocrawl)) {\n                    fprintf(stderr, \"lru_crawler_tocrawl takes a numeric 32bit value\\n\");\n                    return 1;\n                }\n                settings.lru_crawler_tocrawl = tocrawl;\n                break;\n            case LRU_MAINTAINER:\n                start_lru_maintainer = true;\n                break;\n            case HOT_LRU_PCT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing hot_lru_pct argument\\n\");\n                    return 1;\n                };\n                settings.hot_lru_pct = atoi(subopts_value);\n                if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {\n                    fprintf(stderr, \"hot_lru_pct must be > 1 and < 80\\n\");\n                    return 1;\n                }\n                break;\n            case WARM_LRU_PCT:\n                if (subopts_value == NULL) {\n                    fprintf(stderr, \"Missing warm_lru_pct argument\\n\");\n                    return 1;\n                };\n                settings.warm_lru_pct = atoi(subopts_value);\n                if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {\n                    fprintf(stderr, \"warm_lru_pct must be > 1 and < 80\\n\");\n                    return 1;\n                }\n                break;\n            case NOEXP_NOEVICT:\n                settings.expirezero_does_not_evict = true;\n                break;\n            default:\n                printf(\"Illegal suboption \\\"%s\\\"\\n\", subopts_value);\n                return 1;\n            }\n\n            }\n            free(subopts_orig);\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    if (settings.lru_maintainer_thread && settings.hot_lru_pct + settings.warm_lru_pct > 80) {\n        fprintf(stderr, \"hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\\n\");\n        exit(EX_USAGE);\n    }\n\n    if (hash_init(hash_type) != 0) {\n        fprintf(stderr, \"Failed to initialize hash_algorithm!\\n\");\n        exit(EX_USAGE);\n    }\n\n    \n\n\n\n    if (settings.inter != NULL && strchr(settings.inter, ',')) {\n        settings.num_threads_per_udp = 1;\n    } else {\n        settings.num_threads_per_udp = settings.num_threads;\n    }\n\n    if (settings.sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol != binary_prot) {\n                fprintf(stderr, \"ERROR: You cannot allow the ASCII protocol while using SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (tcp_specified && !udp_specified) {\n        settings.udpport = settings.port;\n    } else if (udp_specified && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        \n\n\n\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                \n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        \n\n\n\n\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            fprintf(stderr, \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    \n\n\n\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        fprintf(stderr, \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        rlim.rlim_cur = settings.maxconns;\n        rlim.rlim_max = settings.maxconns;\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            fprintf(stderr, \"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    \n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            fprintf(stderr, \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            fprintf(stderr, \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            fprintf(stderr, \"failed to assume identity of user %s\\n\", username);\n            exit(EX_OSERR);\n        }\n    }\n\n    \n    if (settings.sasl) {\n        init_sasl();\n    }\n\n    \n    \n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            perror(\"Failed to ignore SIGHUP\");\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n            fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    \n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            fprintf(stderr, \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    \n    main_base = event_init();\n\n    \n    stats_init();\n    assoc_init(settings.hashpower_init);\n    conn_init();\n    slabs_init(settings.maxbytes, settings.factor, preallocate);\n\n    \n\n\n\n    if (sigignore(SIGPIPE) == -1) {\n        perror(\"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n    \n    memcached_thread_init(settings.num_threads, main_base);\n\n    if (start_assoc_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    if (start_lru_crawler && start_item_crawler_thread() != 0) {\n        fprintf(stderr, \"Failed to enable LRU crawler thread\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (start_lru_maintainer && start_lru_maintainer_thread() != 0) {\n        fprintf(stderr, \"Failed to enable LRU maintainer thread\\n\");\n        return 1;\n    }\n\n    if (settings.slab_reassign &&\n        start_slab_maintenance_thread() == -1) {\n        exit(EXIT_FAILURE);\n    }\n\n    \n    clock_handler(0, 0, 0);\n\n    \n    if (settings.socketpath != NULL) {\n        errno = 0;\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\n            exit(EX_OSERR);\n        }\n    }\n\n    \n    if (settings.socketpath == NULL) {\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char *temp_portnumber_filename = NULL;\n        size_t len;\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            len = strlen(portnumber_filename)+4+1;\n            temp_portnumber_filename = malloc(len);\n            snprintf(temp_portnumber_filename,\n                     len,\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        errno = 0;\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                           portnumber_file)) {\n            vperror(\"failed to listen on TCP port %d\", settings.port);\n            exit(EX_OSERR);\n        }\n\n        \n\n\n\n\n\n\n        \n        errno = 0;\n        if (settings.udpport && server_sockets(settings.udpport, udp_transport,\n                                              portnumber_file)) {\n            vperror(\"failed to listen on UDP port %d\", settings.udpport);\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n            free(temp_portnumber_filename);\n        }\n    }\n\n    \n\n\n    usleep(1000);\n    if (stats.curr_conns + stats.reserved_fds >= settings.maxconns - 1) {\n        fprintf(stderr, \"Maxconns setting is too low, use -c to increase.\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    \n    drop_privileges();\n\n    \n    if (event_base_loop(main_base, 0) != 0) {\n        retval = EXIT_FAILURE;\n    }\n\n    stop_assoc_maintenance_thread();\n\n    \n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    \n    if (settings.inter)\n      free(settings.inter);\n    if (l_socket)\n      free(l_socket);\n    if (u_socket)\n      free(u_socket);\n\n    return retval;\n}"
            }
        ],
        "Links": [
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/memcached.c#L5733"
        ]
    },
    {
        "Function Path": "<        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);, conn_new> --> <conn_new(item->sfd, item->init_state, item->event_flags,\\n                           item->read_buffer_size, item->transport, me->base), thread_libevent_process>",
        "Path": "<Lines: 10-58, 60-139, Source: `        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);`,  Function: `conn_new`, Status: Unknown. File: ../benchmark/C/memcached/memcached.c> --> <Lines: 14-15,17,28-31,33,39, Source: `conn_new(item->sfd, item->init_state, item->event_flags,\\n                           item->read_buffer_size, item->transport, me->base)`,  Function: `thread_libevent_process`, Status: Bug. File: ../benchmark/C/memcached/thread.c>",
        "Explanation": "`c` (containing `msglist`) is returned to the caller.\\nThe memory allocated for 'c' at line 15 is not freed and not propagated to other functions, resulting in a memory leak.",
        "Model": "Deepseek-R1",
        "Is Reproduce": "No",
        "Functions": [
            {
                "Function": "conn_new",
                "Function Body": "conn *conn_new(const int sfd, enum conn_states init_state,\n                const int event_flags,\n                const int read_buffer_size, enum network_transport transport,\n                struct event_base *base) {\n    conn *c;\n\n    assert(sfd >= 0 && sfd < max_fds);\n    c = conns[sfd];\n\n    if (NULL == c) {\n        if (!(c = (conn *)calloc(1, sizeof(conn)))) {\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            fprintf(stderr, \"Failed to allocate connection object\\n\");\n            return NULL;\n        }\n        MEMCACHED_CONN_CREATE(c);\n\n        c->rbuf = c->wbuf = 0;\n        c->ilist = 0;\n        c->suffixlist = 0;\n        c->iov = 0;\n        c->msglist = 0;\n        c->hdrbuf = 0;\n\n        c->rsize = read_buffer_size;\n        c->wsize = DATA_BUFFER_SIZE;\n        c->isize = ITEM_LIST_INITIAL;\n        c->suffixsize = SUFFIX_LIST_INITIAL;\n        c->iovsize = IOV_LIST_INITIAL;\n        c->msgsize = MSG_LIST_INITIAL;\n        c->hdrsize = 0;\n\n        c->rbuf = (char *)malloc((size_t)c->rsize);\n        c->wbuf = (char *)malloc((size_t)c->wsize);\n        c->ilist = (item **)malloc(sizeof(item *) * c->isize);\n        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);\n        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);\n        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);\n\n        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||\n                c->msglist == 0 || c->suffixlist == 0) {\n            conn_free(c);\n            STATS_LOCK();\n            stats.malloc_fails++;\n            STATS_UNLOCK();\n            fprintf(stderr, \"Failed to allocate buffers for connection\\n\");\n            return NULL;\n        }\n\n        STATS_LOCK();\n        stats.conn_structs++;\n        STATS_UNLOCK();\n\n        c->sfd = sfd;\n        conns[sfd] = c;\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    \n\n\n    if (!settings.socketpath) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (transport == tcp_transport && init_state == conn_new_cmd) {\n        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,\n                        &c->request_addr_size)) {\n            perror(\"getpeername\");\n            memset(&c->request_addr, 0, sizeof(c->request_addr));\n        }\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            fprintf(stderr, \"<%d server listening (%s)\\n\", sfd,\n                prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            fprintf(stderr, \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            fprintf(stderr, \"<%d new auto-negotiating client connection\\n\",\n                    sfd);\n        } else if (c->protocol == ascii_prot) {\n            fprintf(stderr, \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            fprintf(stderr, \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            fprintf(stderr, \"<%d new unknown (%d) client connection\\n\",\n                sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->authenticated = false;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (event_add(&c->event, 0) == -1) {\n        perror(\"event_add\");\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.curr_conns++;\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    return c;\n}"
            },
            {
                "Function": "thread_libevent_process",
                "Function Body": "static void thread_libevent_process(int fd, short which, void *arg) {\n    LIBEVENT_THREAD *me = arg;\n    CQ_ITEM *item;\n    char buf[1];\n\n    if (read(fd, buf, 1) != 1)\n        if (settings.verbose > 0)\n            fprintf(stderr, \"Can't read from libevent pipe\\n\");\n\n    switch (buf[0]) {\n    case 'c':\n    item = cq_pop(me->new_conn_queue);\n\n    if (NULL != item) {\n        conn *c = conn_new(item->sfd, item->init_state, item->event_flags,\n                           item->read_buffer_size, item->transport, me->base);\n        if (c == NULL) {\n            if (IS_UDP(item->transport)) {\n                fprintf(stderr, \"Can't listen for events on UDP socket\\n\");\n                exit(1);\n            } else {\n                if (settings.verbose > 0) {\n                    fprintf(stderr, \"Can't listen for events on fd %d\\n\",\n                        item->sfd);\n                }\n                close(item->sfd);\n            }\n        } else {\n            c->thread = me;\n        }\n        cqi_free(item);\n    }\n        break;\n    \n    case 'p':\n    register_thread_initialized();\n        break;\n    }\n}"
            }
        ],
        "Links": [
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/memcached.c#L399",
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/thread.c#L400"
        ]
    },
    {
        "Function Path": "<    cache_t* ret = calloc(1, sizeof(cache_t));, cache_create> --> <cache_create(\\\"test\\\", sizeof(uint32_t), sizeof(char*),\\n                                  NULL, NULL), cache_redzone_test>",
        "Path": "<Lines: 4-8, 15-27, Source: `    cache_t* ret = calloc(1, sizeof(cache_t));`,  Function: `cache_create`, Status: Unknown. File: ../benchmark/C/memcached/cache.c> --> <Lines: 4-18, Source: `cache_create(\\\"test\\\", sizeof(uint32_t), sizeof(char*),\\n                                  NULL, NULL)`,  Function: `cache_redzone_test`, Status: Bug. File: ../benchmark/C/memcached/testapp.c>",
        "Explanation": "The pointer `ret` at line 4 is returned to the caller of `cache_create` at line 27.\\nThe assert at line 18 fails, causing program termination. The pointer `cache` at line 4 is not freed, resulting in a memory leak.",
        "Model": "Deepseek-R1",
        "Is Reproduce": "No",
        "Functions": [
            {
                "Function": "cache_create",
                "Function Body": "cache_t* cache_create(const char *name, size_t bufsize, size_t align,\n                      cache_constructor_t* constructor,\n                      cache_destructor_t* destructor) {\n    cache_t* ret = calloc(1, sizeof(cache_t));\n    char* nm = strdup(name);\n    void** ptr = calloc(initial_pool_size, sizeof(void*));\n    if (ret == NULL || nm == NULL || ptr == NULL ||\n        pthread_mutex_init(&ret->mutex, NULL) == -1) {\n        free(ret);\n        free(nm);\n        free(ptr);\n        return NULL;\n    }\n\n    ret->name = nm;\n    ret->ptr = ptr;\n    ret->freetotal = initial_pool_size;\n    ret->constructor = constructor;\n    ret->destructor = destructor;\n\n#ifndef NDEBUG\n    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);\n#else\n    ret->bufsize = bufsize;\n#endif\n\n    return ret;\n}"
            },
            {
                "Function": "cache_redzone_test",
                "Function Body": "static enum test_return cache_redzone_test(void)\n{\n#ifndef HAVE_UMEM_H\n    cache_t *cache = cache_create(\"test\", sizeof(uint32_t), sizeof(char*),\n                                  NULL, NULL);\n\n    \n    struct sigaction old_action;\n    struct sigaction action = { .sa_handler = SIG_IGN, .sa_flags = 0};\n    sigemptyset(&action.sa_mask);\n    sigaction(SIGABRT, &action, &old_action);\n\n    \n    char *p = cache_alloc(cache);\n    char old = *(p - 1);\n    *(p - 1) = 0;\n    cache_free(cache, p);\n    assert(cache_error == -1);\n    *(p - 1) = old;\n\n    p[sizeof(uint32_t)] = 0;\n    cache_free(cache, p);\n    assert(cache_error == 1);\n\n    \n    sigaction(SIGABRT, &old_action, NULL);\n\n    cache_destroy(cache);\n\n    return TEST_PASS;\n#else\n    return TEST_SKIP;\n#endif\n}"
            }
        ],
        "Links": [
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/cache.c#L22",
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/testapp.c#L153"
        ]
    },
    {
        "Function Path": "<        object = ret = malloc(cache->bufsize);, cache_alloc> --> <ptr, get_object> --> <get_object(ret), cache_alloc> --> <cache_alloc(cache), cache_fail_constructor_test>",
        "Path": "<Lines: 9-13 (constructor check skipped), 20, 22-30, 33, Source: `        object = ret = malloc(cache->bufsize);`,  Function: `cache_alloc`, Status: Unknown. File: ../benchmark/C/memcached/cache.c> --> <Lines: 2-4, Source: `ptr`,  Function: `get_object`, Status: Unknown. File: ../benchmark/C/memcached/cache.c> --> <Lines: 5-7, 20, 33, Source: `get_object(ret)`,  Function: `cache_alloc`, Status: Unknown. File: ../benchmark/C/memcached/cache.c> --> <Lines: 8-10,12-13, Source: `cache_alloc(cache)`,  Function: `cache_fail_constructor_test`, Status: Bug. File: ../benchmark/C/memcached/testapp.c>",
        "Explanation": "`ret` (src) is passed to `get_object` at line 11.\\nThe pointer `ptr` at line 1 is propagated to the caller via `return pre + 1` (line 4).  \\n`object` (derived from `ret`) is returned to the caller.  \\nThe pointer `ptr` at line 8 is not freed and not propagated to any function, causing a memory leak.",
        "Model": "Deepseek-R1",
        "Is Reproduce": "No",
        "Functions": [
            {
                "Function": "cache_alloc",
                "Function Body": "void* cache_alloc(cache_t *cache) {\n    void *ret;\n    void *object;\n    pthread_mutex_lock(&cache->mutex);\n    if (cache->freecurr > 0) {\n        ret = cache->ptr[--cache->freecurr];\n        object = get_object(ret);\n    } else {\n        object = ret = malloc(cache->bufsize);\n        if (ret != NULL) {\n            object = get_object(ret);\n\n            if (cache->constructor != NULL &&\n                cache->constructor(object, NULL, 0) != 0) {\n                free(ret);\n                object = NULL;\n            }\n        }\n    }\n    pthread_mutex_unlock(&cache->mutex);\n\n#ifndef NDEBUG\n    if (object != NULL) {\n        \n        uint64_t *pre = ret;\n        *pre = redzone_pattern;\n        ret = pre+1;\n        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),\n               &redzone_pattern, sizeof(redzone_pattern));\n    }\n#endif\n\n    return object;\n}"
            },
            {
                "Function": "get_object",
                "Function Body": "static inline void* get_object(void *ptr) {\n#ifndef NDEBUG\n    uint64_t *pre = ptr;\n    return pre + 1;\n#else\n    return ptr;\n#endif\n}"
            },
            {
                "Function": "cache_alloc",
                "Function Body": "void* cache_alloc(cache_t *cache) {\n    void *ret;\n    void *object;\n    pthread_mutex_lock(&cache->mutex);\n    if (cache->freecurr > 0) {\n        ret = cache->ptr[--cache->freecurr];\n        object = get_object(ret);\n    } else {\n        object = ret = malloc(cache->bufsize);\n        if (ret != NULL) {\n            object = get_object(ret);\n\n            if (cache->constructor != NULL &&\n                cache->constructor(object, NULL, 0) != 0) {\n                free(ret);\n                object = NULL;\n            }\n        }\n    }\n    pthread_mutex_unlock(&cache->mutex);\n\n#ifndef NDEBUG\n    if (object != NULL) {\n        \n        uint64_t *pre = ret;\n        *pre = redzone_pattern;\n        ret = pre+1;\n        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),\n               &redzone_pattern, sizeof(redzone_pattern));\n    }\n#endif\n\n    return object;\n}"
            },
            {
                "Function": "cache_fail_constructor_test",
                "Function Body": "static enum test_return cache_fail_constructor_test(void)\n{\n    enum test_return ret = TEST_PASS;\n\n    cache_t *cache = cache_create(\"test\", sizeof(uint64_t), sizeof(uint64_t),\n                                  cache_fail_constructor, NULL);\n    assert(cache != NULL);\n    uint64_t *ptr = cache_alloc(cache);\n    if (ptr != NULL) {\n        ret = TEST_FAIL;\n    }\n    cache_destroy(cache);\n    return ret;\n}"
            }
        ],
        "Links": [
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/cache.c#L79",
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/cache.c#L48",
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/cache.c#L77",
            "https://github.com/memcached/memcached/tree/e15e1d6b967eed53ddcfd61c0c90c38d0b017996/testapp.c#L75"
        ]
    }
]