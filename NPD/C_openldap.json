[
    {
        "Function Path": "<\treturn ber_strdup_x( s, NULL );, ber_strdup> --> <ber_strdup( urlstr ), ldif_open_url> --> <s, ldap_pvt_hex_unescape>",
        "Path": "<Lines: 2-4, Source: `\treturn ber_strdup_x( s, NULL );`,  Function: `ber_strdup`, Status: Unknown. File: ../benchmark/C/openldap/libraries/liblber/memory.c> --> <Lines: 7-32, 35-46, 53, Source: `ber_strdup( urlstr )`,  Function: `ldif_open_url`, Status: Unknown. File: ../benchmark/C/openldap/libraries/libldap/fetch.c> --> <Lines: 2-11, Source: `s`,  Function: `ldap_pvt_hex_unescape`, Status: Bug. File: ../benchmark/C/openldap/libraries/libldap/url.c>",
        "Explanation": "The return value of ber_strdup_x containing NULL value is returned to the caller of function ber_strdup at line 4.\nThe NULL value of pointer `p` from line 32 is passed as argument.\nThe NULL value of parameter `s` at line 2 is dereferenced in the loop condition at line 11 without any NULL check.",
        "Model": "Claude-3.5, Deepseek-R1",
        "Is Reproduce": "Yes",
        "Functions": [
            {
                "Function": "ber_strdup",
                "Function Body": "char *\nber_strdup( LDAP_CONST char *s )\n{\n\treturn ber_strdup_x( s, NULL );\n}"
            },
            {
                "Function": "ldif_open_url",
                "Function Body": "FILE *\nldif_open_url(\n\tLDAP_CONST char *urlstr )\n{\n\tFILE *url;\n\n\tif( strncasecmp( \"file:\", urlstr, sizeof(\"file:\")-1 ) == 0 ) {\n\t\tchar *p;\n\t\turlstr += sizeof(\"file:\")-1;\n\n\t\t\n\t\tif ( urlstr[0] == '/' && urlstr[1] == '/' ) {\n\t\t\turlstr += 2;\n\t\t\t\n\n\n\n\t\t\tif ( urlstr[0] != '/' ) {\n#ifdef _WIN32\n\t\t\t\t\n\t\t\t\tif ( urlstr[1] != ':' )\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n#ifdef _WIN32\n\t\t\t\n\t\t\tif ( urlstr[2] == ':' )\n\t\t\t\turlstr++;\n#endif\n\t\t}\n\n\t\tp = ber_strdup( urlstr );\n\n\t\t\n\t\tif ( LDAP_DIRSEP[0] != '/' ) {\n\t\t\tchar *s = p;\n\t\t\twhile (( s = strchr( s, '/' )))\n\t\t\t\t*s++ = LDAP_DIRSEP[0];\n\t\t}\n\n\t\tldap_pvt_hex_unescape( p );\n\n\t\turl = fopen( p, \"rb\" );\n\n\t\tber_memfree( p );\n\t} else {\n#ifdef HAVE_FETCH\n\t\turl = fetchGetURL( (char*) urlstr, \"\" );\n#else\n\t\turl = NULL;\n#endif\n\t}\n\treturn url;\n}"
            },
            {
                "Function": "ldap_pvt_hex_unescape",
                "Function Body": "void\nldap_pvt_hex_unescape( char *s )\n{\n\t\n\n\n\n\tchar\t*p,\n\t\t*save_s = s;\n\n\tfor ( p = s; *s != '\\0'; ++s ) {\n\t\tif ( *s == '%' ) {\n\t\t\t\n\n\n\n\t\t\tif ( !ldap_int_is_hexpair( s + 1 ) ) {\n\t\t\t\tp = save_s;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( *++s == '\\0' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*p = ldap_int_unhex( *s ) << 4;\n\t\t\tif ( *++s == '\\0' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*p++ += ldap_int_unhex( *s );\n\t\t} else {\n\t\t\t*p++ = *s;\n\t\t}\n\t}\n\n\t*p = '\\0';\n}"
            }
        ],
        "Links": [
            "https://github.com/openldap/openldap/tree/519e0c94c9f3804813f691de487283ad7586f510/libraries/liblber/memory.c#L653",
            "https://github.com/openldap/openldap/tree/519e0c94c9f3804813f691de487283ad7586f510/libraries/libldap/fetch.c#L71",
            "https://github.com/openldap/openldap/tree/519e0c94c9f3804813f691de487283ad7586f510/libraries/libldap/url.c#L1616"
        ]
    },
    {
        "Function Path": "<\treturn ber_strdup_x( s, NULL );, ber_strdup> --> <ber_strdup( pw ), tool_bind>",
        "Path": "<Lines: 2-4, Source: `\treturn ber_strdup_x( s, NULL );`,  Function: `ber_strdup`, Status: Unknown. File: ../benchmark/C/openldap/libraries/liblber/memory.c> --> <Lines: 81-82, Source: `ber_strdup( pw )`,  Function: `tool_bind`, Status: Bug. File: ../benchmark/C/openldap/clients/tools/common.c>",
        "Explanation": "The return value of ber_strdup_x containing NULL value is returned to the caller of function ber_strdup at line 4.\nThe NULL value from ber_strdup(pw) at line 81 is dereferenced without check.",
        "Model": "Claude-3.5, Deepseek-R1",
        "Is Reproduce": "No",
        "Functions": [
            {
                "Function": "ber_strdup",
                "Function Body": "char *\nber_strdup( LDAP_CONST char *s )\n{\n\treturn ber_strdup_x( s, NULL );\n}"
            },
            {
                "Function": "tool_bind",
                "Function Body": "void\ntool_bind( LDAP *ld )\n{\n\tLDAPControl\t**sctrlsp = NULL;\n\tLDAPControl\t*sctrls[4];\n\tLDAPControl\tsctrl[3];\n\tint\t\tnsctrls = 0;\n\n\tint rc, msgid;\n\tLDAPMessage *result = NULL;\n\n\tint err;\n\tchar *matched = NULL;\n\tchar *info = NULL;\n\tchar **refs = NULL;\n\tLDAPControl **ctrls = NULL;\n\tchar msgbuf[256];\n\n\tmsgbuf[0] = 0;\n\n#ifdef LDAP_CONTROL_PASSWORDPOLICYREQUEST\n\tif ( ppolicy ) {\n\t\tLDAPControl c;\n\t\tc.ldctl_oid = LDAP_CONTROL_PASSWORDPOLICYREQUEST;\n\t\tc.ldctl_value.bv_val = NULL;\n\t\tc.ldctl_value.bv_len = 0;\n\t\tc.ldctl_iscritical = 0;\n\t\tsctrl[nsctrls] = c;\n\t\tsctrls[nsctrls] = &sctrl[nsctrls];\n\t\tsctrls[++nsctrls] = NULL;\n\t}\n#endif\n\n\tif ( bauthzid ) {\n\t\tLDAPControl c;\n\n\t\tc.ldctl_oid = LDAP_CONTROL_AUTHZID_REQUEST;\n\t\tc.ldctl_iscritical = bauthzid > 1;\n\t\tBER_BVZERO( &c.ldctl_value );\n\n\t\tsctrl[nsctrls] = c;\n\t\tsctrls[nsctrls] = &sctrl[nsctrls];\n\t\tsctrls[++nsctrls] = NULL;\n\t}\n\n#ifdef LDAP_CONTROL_X_SESSION_TRACKING\n\tif ( sessionTracking ) {\n\t\tLDAPControl c;\n\n\t\tif ( BER_BVISNULL( &stValue) && st_value( ld, &stValue ) ) {\n\t\t\ttool_exit( ld, EXIT_FAILURE );\n\t\t}\n\n\t\tc.ldctl_oid = LDAP_CONTROL_X_SESSION_TRACKING;\n\t\tc.ldctl_iscritical = 0;\n\t\tc.ldctl_value = stValue;\n\n\t\tsctrl[nsctrls] = c;\n\t\tsctrls[nsctrls] = &sctrl[nsctrls];\n\t\tsctrls[++nsctrls] = NULL;\n\t}\n#endif \n\n\tif ( nsctrls ) {\n\t\tsctrlsp = sctrls;\n\t}\n\n\tassert( nsctrls < (int) (sizeof(sctrls)/sizeof(sctrls[0])) );\n\n\tif ( pw_file || want_bindpw ) {\n\t\tassert( passwd.bv_val == NULL && passwd.bv_len == 0 );\n\n\t\tif ( pw_file ) {\n\t\t\tif ( lutil_get_filed_password( pw_file, &passwd ) ) {\n\t\t\t\ttool_exit( ld, EXIT_FAILURE );\n\t\t\t}\n\n\t\t} else {\n\t\t\tchar *pw = getpassphrase( _(\"Enter LDAP Password: \") );\n\t\t\tif ( pw ) {\n\t\t\t\tpasswd.bv_val = ber_strdup( pw );\n\t\t\t\tpasswd.bv_len = strlen( passwd.bv_val );\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( authmethod == LDAP_AUTH_SASL ) {\n#ifdef HAVE_CYRUS_SASL\n\t\tvoid *defaults;\n\t\tconst char *rmech = NULL;\n\n\t\tif( sasl_secprops != NULL ) {\n\t\t\trc = ldap_set_option( ld, LDAP_OPT_X_SASL_SECPROPS,\n\t\t\t\t(void *) sasl_secprops );\n\n\t\t\tif( rc != LDAP_OPT_SUCCESS ) {\n\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\"Could not set LDAP_OPT_X_SASL_SECPROPS: %s\\n\",\n\t\t\t\t\tsasl_secprops );\n\t\t\t\ttool_exit( ld, LDAP_LOCAL_ERROR );\n\t\t\t}\n\t\t}\n\n\t\tdefaults = lutil_sasl_defaults( ld,\n\t\t\tsasl_mech,\n\t\t\tsasl_realm,\n\t\t\tsasl_authc_id,\n\t\t\tpasswd.bv_val,\n\t\t\tsasl_authz_id );\n\n\t\tdo {\n\t\t\trc = ldap_sasl_interactive_bind( ld, binddn, sasl_mech,\n\t\t\t\tsctrlsp, NULL, sasl_flags, lutil_sasl_interact, defaults,\n\t\t\t\tresult, &rmech, &msgid );\n\n\t\t\tif ( rc != LDAP_SASL_BIND_IN_PROGRESS )\n\t\t\t\tbreak;\n\n\t\t\tldap_msgfree( result );\n\n\t\t\tif ( ldap_result( ld, msgid, LDAP_MSG_ALL, NULL, &result ) == -1 || !result ) {\n\t\t\t\tldap_get_option( ld, LDAP_OPT_RESULT_CODE, (void*)&err );\n\t\t\t\tldap_get_option( ld, LDAP_OPT_DIAGNOSTIC_MESSAGE, (void*)&info );\n\t\t\t\ttool_perror( \"ldap_sasl_interactive_bind\",\n\t\t\t\t\terr, NULL, NULL, info, NULL );\n\t\t\t\tldap_memfree( info );\n\t\t\t\ttool_exit( ld, err );\n\t\t\t}\n\t\t} while ( rc == LDAP_SASL_BIND_IN_PROGRESS );\n\n\t\tlutil_sasl_freedefs( defaults );\n\n\t\tif ( rc != LDAP_SUCCESS ) {\n\t\t\tldap_get_option( ld, LDAP_OPT_DIAGNOSTIC_MESSAGE, (void*)&info );\n\t\t\ttool_perror( \"ldap_sasl_interactive_bind\",\n\t\t\t\trc, NULL, NULL, info, NULL );\n\t\t\tldap_memfree( info );\n\t\t\ttool_exit( ld, rc );\n\t\t}\n#else\n\t\tfprintf( stderr, \"%s: not compiled with SASL support\\n\", prog );\n\t\ttool_exit( ld, LDAP_NOT_SUPPORTED );\n#endif\n\t} else {\n\t\t\n\t\trc = ldap_sasl_bind( ld, binddn, LDAP_SASL_SIMPLE, &passwd,\n\t\t\tsctrlsp, NULL, &msgid );\n\t\tif ( msgid == -1 ) {\n\t\t\ttool_perror( \"ldap_sasl_bind(SIMPLE)\", rc,\n\t\t\t\tNULL, NULL, NULL, NULL );\n\t\t\ttool_exit( ld, rc );\n\t\t}\n\n\t\trc = ldap_result( ld, msgid, LDAP_MSG_ALL, NULL, &result );\n\t\tif ( rc == -1 ) {\n\t\t\ttool_perror( \"ldap_result\", -1, NULL, NULL, NULL, NULL );\n\t\t\ttool_exit( ld, LDAP_LOCAL_ERROR );\n\t\t}\n\n\t\tif ( rc == 0 ) {\n\t\t\ttool_perror( \"ldap_result\", LDAP_TIMEOUT, NULL, NULL, NULL, NULL );\n\t\t\ttool_exit( ld, LDAP_LOCAL_ERROR );\n\t\t}\n\t}\n\n\tif ( result ) {\n\t\trc = ldap_parse_result( ld, result, &err, &matched, &info, &refs,\n\t\t                        &ctrls, 1 );\n\t\tif ( rc != LDAP_SUCCESS ) {\n\t\t\ttool_perror( \"ldap_bind parse result\", rc, NULL, matched, info, refs );\n\t\t\ttool_exit( ld, LDAP_LOCAL_ERROR );\n\t\t}\n\t}\n\n#ifdef LDAP_CONTROL_PASSWORDPOLICYREQUEST\n\tif ( ctrls && ppolicy ) {\n\t\tLDAPControl *ctrl;\n\t\tint expire, grace, len = 0;\n\t\tLDAPPasswordPolicyError pErr = -1;\n\t\t\n\t\tctrl = ldap_control_find( LDAP_CONTROL_PASSWORDPOLICYRESPONSE,\n\t\t\tctrls, NULL );\n\n\t\tif ( ctrl && ldap_parse_passwordpolicy_control( ld, ctrl,\n\t\t\t&expire, &grace, &pErr ) == LDAP_SUCCESS )\n\t\t{\n\t\t\tif ( pErr != PP_noError ){\n\t\t\t\tmsgbuf[0] = ';';\n\t\t\t\tmsgbuf[1] = ' ';\n\t\t\t\tstrcpy( msgbuf+2, ldap_passwordpolicy_err2txt( pErr ));\n\t\t\t\tlen = strlen( msgbuf );\n\t\t\t}\n\t\t\tif ( expire >= 0 ) {\n\t\t\t\tsprintf( msgbuf+len,\n\t\t\t\t\t\" (Password expires in %d seconds)\",\n\t\t\t\t\texpire );\n\t\t\t} else if ( grace >= 0 ) {\n\t\t\t\tsprintf( msgbuf+len,\n\t\t\t\t\t\" (Password expired, %d grace logins remain)\",\n\t\t\t\t\tgrace );\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif ( ctrls && bauthzid ) {\n\t\tLDAPControl *ctrl;\n\t\t\n\t\tctrl = ldap_control_find( LDAP_CONTROL_AUTHZID_RESPONSE,\n\t\t\tctrls, NULL );\n\t\tif ( ctrl ) {\n\t\t\tLDAPControl *ctmp[2];\n\t\t\tctmp[0] = ctrl;\n\t\t\tctmp[1] = NULL;\n\t\t\ttool_print_ctrls( ld, ctmp );\n\t\t}\n\t}\n\n#ifdef LDAP_CONTROL_X_PASSWORD_EXPIRED\n\tif ( ctrls ) {\n\t\tLDAPControl *ctrl;\n\t\tctrl = ldap_control_find( LDAP_CONTROL_X_PASSWORD_EXPIRED,\n\t\t\tctrls, NULL );\n\t\tif ( !ctrl )\n\t\t\tctrl = ldap_control_find( LDAP_CONTROL_X_PASSWORD_EXPIRING,\n\t\t\t\tctrls, NULL );\n\t\tif ( ctrl ) {\n\t\t\tLDAPControl *ctmp[2];\n\t\t\tctmp[0] = ctrl;\n\t\t\tctmp[1] = NULL;\n\t\t\ttool_print_ctrls( ld, ctmp );\n\t\t}\n\t}\n#endif\n\n\tif ( ctrls ) {\n\t\tldap_controls_free( ctrls );\n\t}\n\n\tif ( err != LDAP_SUCCESS\n\t\t|| msgbuf[0]\n\t\t|| ( matched && matched[ 0 ] )\n\t\t|| ( info && info[ 0 ] )\n\t\t|| refs )\n\t{\n\t\ttool_perror( \"ldap_bind\", err, msgbuf, matched, info, refs );\n\n\t\tif( matched ) ber_memfree( matched );\n\t\tif( info ) ber_memfree( info );\n\t\tif( refs ) ber_memvfree( (void **)refs );\n\n\t\tif ( err != LDAP_SUCCESS ) tool_exit( ld, err );\n\t}\n}"
            }
        ],
        "Links": [
            "https://github.com/openldap/openldap/tree/519e0c94c9f3804813f691de487283ad7586f510/libraries/liblber/memory.c#L653",
            "https://github.com/openldap/openldap/tree/519e0c94c9f3804813f691de487283ad7586f510/clients/tools/common.c#L1476"
        ]
    },
    {
        "Function Path": "<\\treturn ber_strdup_x( s, NULL );, ber_strdup> --> <ber_strdup( optarg ), tool_args>",
        "Path": "<Lines: 4, Source: `\\treturn ber_strdup_x( s, NULL );`,  Function: `ber_strdup`, Status: Unknown. File: ../benchmark/C/openldap/libraries/liblber/memory.c> --> <Lines: 569-578, Source: `ber_strdup( optarg )`,  Function: `tool_args`, Status: Bug. File: ../benchmark/C/openldap/clients/tools/common.c>",
        "Explanation": "The return value of ber_strdup_x is returned to the caller of function ber_strdup.\\nThe NULL value get from function ber_strdup at line 569 propagates to pointer `passwd.bv_val` at line 569, then the pointer `passwd.bv_val` is deferenced at line 577 with strlen operation without any NULL check.",
        "Model": "Claude-3.5, Deepseek-R1",
        "Is Reproduce": "No",
        "Functions": [
            {
                "Function": "ber_strdup",
                "Function Body": "char *\nber_strdup( LDAP_CONST char *s )\n{\n\treturn ber_strdup_x( s, NULL );\n}"
            },
            {
                "Function": "tool_args",
                "Function Body": "void\ntool_args( int argc, char **argv )\n{\n\tint i;\n\n\twhile (( i = getopt( argc, argv, options )) != EOF ) {\n\t\tint crit, ival;\n\t\tchar *control, *cvalue, *next;\n\t\tswitch( i ) {\n\t\tcase 'c':\t\n\t\t\tcontoper++;\n\t\t\tbreak;\n\t\tcase 'C':\t\n\t\t\treferrals++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tival = strtol( optarg, &next, 10 );\n\t\t\tif (next == NULL || next[0] != '\\0') {\n\t\t\t\tfprintf( stderr, \"%s: unable to parse debug value \\\"%s\\\"\\n\", prog, optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tdebug |= ival;\n\t\t\tbreak;\n\t\tcase 'D':\t\n\t\t\tif( binddn != NULL ) {\n\t\t\t\tfprintf( stderr, \"%s: -D previously specified\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tbinddn = optarg;\n\t\t\tbreak;\n\t\tcase 'e':\t\n\t\t\t\n\n\n\n\t\t\tcrit = 0;\n\t\t\tcvalue = NULL;\n\t\t\twhile ( optarg[0] == '!' ) {\n\t\t\t\tcrit++;\n\t\t\t\toptarg++;\n\t\t\t}\n\n\t\t\tcontrol = optarg;\n\t\t\tif ( (cvalue = strchr( control, '=' )) != NULL ) {\n\t\t\t\t*cvalue++ = '\\0';\n\t\t\t}\n\n\t\t\tif ( strcasecmp( control, \"assert\" ) == 0 ) {\n\t\t\t\tif( assertctl ) {\n\t\t\t\t\tfprintf( stderr, \"assert control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tif( cvalue == NULL ) {\n\t\t\t\t\tfprintf( stderr, \"assert: control value expected\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\n\t\t\t\tassertctl = 1 + crit;\n\n\t\t\t\tassert( assertion == NULL );\n\t\t\t\tassertion = cvalue;\n\n\t\t\t} else if ( strcasecmp( control, \"authzid\" ) == 0 ) {\n\t\t\t\tif( authzid != NULL ) {\n\t\t\t\t\tfprintf( stderr, \"authzid control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n#ifdef LDAP_CONTROL_OBSOLETE_PROXY_AUTHZ\n\t\t\t\tif( proxydn != NULL ) {\n\t\t\t\t\tfprintf( stderr, \"authzid control incompatible with proxydn\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n#endif \n\t\t\t\tif( cvalue == NULL ) {\n\t\t\t\t\tfprintf( stderr, \"authzid: control value expected\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tif( !crit ) {\n\t\t\t\t\tfprintf( stderr, \"authzid: must be marked critical\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t} else if ( crit > 1 ) {\n\t\t\t\t\t\n\n\t\t\t\t\tauthzcrit = 0;\n\t\t\t\t}\n\n\t\t\t\tassert( authzid == NULL );\n\t\t\t\tauthzid = cvalue;\n\n#ifdef LDAP_CONTROL_OBSOLETE_PROXY_AUTHZ\n\t\t\t} else if ( strcasecmp( control, \"proxydn\" ) == 0 ) {\n\t\t\t\tif( proxydn != NULL ) {\n\t\t\t\t\tfprintf( stderr, \"proxydn control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tif( authzid != NULL ) {\n\t\t\t\t\tfprintf( stderr, \"proxydn control incompatible with authzid\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tif( cvalue == NULL ) {\n\t\t\t\t\tfprintf( stderr, \"proxydn: control value expected\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tif( !crit ) {\n\t\t\t\t\tfprintf( stderr, \"proxydn: must be marked critical\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t} else if ( crit > 1 ) {\n\t\t\t\t\t\n\n\t\t\t\t\tauthzcrit = 0;\n\t\t\t\t}\n\n\t\t\t\tassert( proxydn == NULL );\n\t\t\t\tproxydn = cvalue;\n#endif \n\n\t\t\t} else if ( strcasecmp( control, \"bauthzid\" ) == 0 ) {\n\t\t\t\tif( bauthzid ) {\n\t\t\t\t\tfprintf( stderr, \"bauthzid control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tif( cvalue != NULL ) {\n\t\t\t\t\tfprintf( stderr, \"bauthzid: no control value expected\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tbauthzid = 1 + crit;\n\n\t\t\t} else if ( ( strcasecmp( control, \"relax\" ) == 0 ) ||\n\t\t\t\t( strcasecmp( control, \"manageDIT\" ) == 0 ) )\n\t\t\t{\n\t\t\t\tif( manageDIT ) {\n\t\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\t\"relax control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tif( cvalue != NULL ) {\n\t\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\t\"relax: no control value expected\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\n\t\t\t\tmanageDIT = 1 + crit;\n\n\t\t\t} else if ( strcasecmp( control, \"manageDSAit\" ) == 0 ) {\n\t\t\t\tif( manageDSAit ) {\n\t\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\t\"manageDSAit control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tif( cvalue != NULL ) {\n\t\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\t\"manageDSAit: no control value expected\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\n\t\t\t\tmanageDSAit = 1 + crit;\n\n\t\t\t} else if ( strcasecmp( control, \"noop\" ) == 0 ) {\n\t\t\t\tif( noop ) {\n\t\t\t\t\tfprintf( stderr, \"noop control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tif( cvalue != NULL ) {\n\t\t\t\t\tfprintf( stderr, \"noop: no control value expected\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\n\t\t\t\tnoop = 1 + crit;\n\n#ifdef LDAP_CONTROL_PASSWORDPOLICYREQUEST\n\t\t\t} else if ( strcasecmp( control, \"ppolicy\" ) == 0 ) {\n\t\t\t\tif( ppolicy ) {\n\t\t\t\t\tfprintf( stderr, \"ppolicy control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tif( cvalue != NULL ) {\n\t\t\t\t\tfprintf( stderr, \"ppolicy: no control value expected\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tif( crit ) {\n\t\t\t\t\tfprintf( stderr, \"ppolicy: critical flag not allowed\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\n\t\t\t\tppolicy = 1;\n#endif\n\n\t\t\t} else if ( strcasecmp( control, \"preread\" ) == 0 ) {\n\t\t\t\tif( preread ) {\n\t\t\t\t\tfprintf( stderr, \"preread control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\n\t\t\t\tpreread = 1 + crit;\n\t\t\t\tpreread_attrs = cvalue;\n\n\t\t\t} else if ( strcasecmp( control, \"postread\" ) == 0 ) {\n\t\t\t\tif( postread ) {\n\t\t\t\t\tfprintf( stderr, \"postread control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\n\t\t\t\tpostread = 1 + crit;\n\t\t\t\tpostread_attrs = cvalue;\n\n#ifdef LDAP_CONTROL_X_CHAINING_BEHAVIOR\n\t\t\t} else if ( strcasecmp( control, \"chaining\" ) == 0 ) {\n\t\t\t\tif ( chaining ) {\n\t\t\t\t\tfprintf( stderr, \"chaining control previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\n\t\t\t\tchaining = 1 + crit;\n\n\t\t\t\tif ( cvalue != NULL ) {\n\t\t\t\t\tchar\t*continuation;\n\n\t\t\t\t\tcontinuation = strchr( cvalue, '/' );\n\t\t\t\t\tif ( continuation ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t*continuation++ = '\\0';\n\t\t\t\t\t\tif ( strcasecmp( continuation, \"chainingPreferred\" ) == 0 ) {\n\t\t\t\t\t\t\tchainingContinuation = LDAP_CHAINING_PREFERRED;\n\t\t\t\t\t\t} else if ( strcasecmp( continuation, \"chainingRequired\" ) == 0 ) {\n\t\t\t\t\t\t\tchainingContinuation = LDAP_CHAINING_REQUIRED;\n\t\t\t\t\t\t} else if ( strcasecmp( continuation, \"referralsPreferred\" ) == 0 ) {\n\t\t\t\t\t\t\tchainingContinuation = LDAP_REFERRALS_PREFERRED;\n\t\t\t\t\t\t} else if ( strcasecmp( continuation, \"referralsRequired\" ) == 0 ) {\n\t\t\t\t\t\t\tchainingContinuation = LDAP_REFERRALS_REQUIRED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\t\t\t\"chaining behavior control \"\n\t\t\t\t\t\t\t\t\"continuation value \\\"%s\\\" invalid\\n\",\n\t\t\t\t\t\t\t\tcontinuation );\n\t\t\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( strcasecmp( cvalue, \"chainingPreferred\" ) == 0 ) {\n\t\t\t\t\t\tchainingResolve = LDAP_CHAINING_PREFERRED;\n\t\t\t\t\t} else if ( strcasecmp( cvalue, \"chainingRequired\" ) == 0 ) {\n\t\t\t\t\t\tchainingResolve = LDAP_CHAINING_REQUIRED;\n\t\t\t\t\t} else if ( strcasecmp( cvalue, \"referralsPreferred\" ) == 0 ) {\n\t\t\t\t\t\tchainingResolve = LDAP_REFERRALS_PREFERRED;\n\t\t\t\t\t} else if ( strcasecmp( cvalue, \"referralsRequired\" ) == 0 ) {\n\t\t\t\t\t\tchainingResolve = LDAP_REFERRALS_REQUIRED;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\t\t\"chaining behavior control \"\n\t\t\t\t\t\t\t\"resolve value \\\"%s\\\" invalid\\n\",\n\t\t\t\t\t\t\tcvalue);\n\t\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t\t}\n\t\t\t\t}\n#endif \n\n#ifdef LDAP_CONTROL_X_SESSION_TRACKING\n\t\t\t} else if ( strcasecmp( control, \"sessiontracking\" ) == 0 ) {\n\t\t\t\tif ( sessionTracking ) {\n\t\t\t\t\tfprintf( stderr, \"%s: session tracking can be only specified once\\n\", prog );\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tsessionTracking = 1;\n\t\t\t\tif ( crit ) {\n\t\t\t\t\tfprintf( stderr, \"sessiontracking: critical flag not allowed\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t\t\tif ( cvalue ) {\n\t\t\t\t\tsessionTrackingName = cvalue;\n\t\t\t\t}\n#endif \n\n\t\t\t\n\t\t\t} else if ( strcasecmp( control, \"abandon\" ) == 0 ) {\n\t\t\t\tabcan = Intr_Abandon;\n\t\t\t\tif ( crit ) {\n\t\t\t\t\tgotintr = abcan;\n\t\t\t\t}\n\n\t\t\t} else if ( strcasecmp( control, \"cancel\" ) == 0 ) {\n\t\t\t\tabcan = Intr_Cancel;\n\t\t\t\tif ( crit ) {\n\t\t\t\t\tgotintr = abcan;\n\t\t\t\t}\n\n\t\t\t} else if ( strcasecmp( control, \"ignore\" ) == 0 ) {\n\t\t\t\tabcan = Intr_Ignore;\n\t\t\t\tif ( crit ) {\n\t\t\t\t\tgotintr = abcan;\n\t\t\t\t}\n\n\t\t\t} else if ( strcasecmp( control, \"backlog\" ) == 0 ) {\n\t\t\t\t\n\n\n\n\t\t\t\tbacklog = 1;\n\n\t\t\t} else if ( tool_is_oid( control ) ) {\n\t\t\t\tLDAPControl\t*tmpctrls, ctrl;\n\n\t\t\t\tif ( unknown_ctrls != NULL ) {\n\t\t\t\t\tint i;\n\t\t\t\t\tfor ( i = 0; unknown_ctrls[ i ].ldctl_oid != NULL; i++ ) {\n\t\t\t\t\t\tif ( strcmp( control, unknown_ctrls[ i ].ldctl_oid ) == 0 ) {\n\t\t\t\t\t\t\tfprintf( stderr, \"%s control previously specified\\n\", control );\n\t\t\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttmpctrls = (LDAPControl *)ber_memrealloc( unknown_ctrls,\n\t\t\t\t\t(unknown_ctrls_num + 1)*sizeof( LDAPControl ) );\n\t\t\t\tif ( tmpctrls == NULL ) {\n\t\t\t\t\tfprintf( stderr, \"%s: no memory?\\n\", prog );\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tunknown_ctrls = tmpctrls;\n\t\t\t\tctrl.ldctl_oid = control;\n\t\t\t\tctrl.ldctl_value.bv_val = NULL;\n\t\t\t\tctrl.ldctl_value.bv_len = 0;\n\t\t\t\tctrl.ldctl_iscritical = crit;\n\n\t\t\t\tif ( cvalue != NULL ) {\n\t\t\t\t\tstruct berval\tbv;\n\t\t\t\t\tsize_t\t\tlen = strlen( cvalue );\n\t\t\t\t\tint\t\tretcode;\n\n\t\t\t\t\tbv.bv_len = LUTIL_BASE64_DECODE_LEN( len );\n\t\t\t\t\tbv.bv_val = ber_memalloc( bv.bv_len + 1 );\n\n\t\t\t\t\tretcode = lutil_b64_pton( cvalue,\n\t\t\t\t\t\t(unsigned char *)bv.bv_val,\n\t\t\t\t\t\tbv.bv_len );\n\n\t\t\t\t\tif ( retcode == -1 || (unsigned) retcode > bv.bv_len ) {\n\t\t\t\t\t\tfprintf( stderr, \"Unable to parse value of general control %s\\n\",\n\t\t\t\t\t\t\tcontrol );\n\t\t\t\t\t\tusage();\n\t\t\t\t\t}\n\n\t\t\t\t\tbv.bv_len = retcode;\n\t\t\t\t\tctrl.ldctl_value = bv;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tcontrol = NULL;\n\t\t\t\tunknown_ctrls[ unknown_ctrls_num ] = ctrl;\n\t\t\t\tunknown_ctrls_num++;\n\n\t\t\t} else {\n\t\t\t\tfprintf( stderr, \"Invalid general control name: %s\\n\",\n\t\t\t\t\tcontrol );\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\t\n\t\t\tif( infile != NULL ) {\n\t\t\t\tfprintf( stderr, \"%s: -f previously specified\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tinfile = optarg;\n\t\t\tbreak;\n\t\tcase 'H':\t\n\t\t\tif( ldapuri != NULL ) {\n\t\t\t\tfprintf( stderr, \"%s: -H previously specified\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tldapuri = ber_strdup( optarg );\n\t\t\tbreak;\n\t\tcase 'I':\n#ifdef HAVE_CYRUS_SASL\n\t\t\tif( authmethod != -1 && authmethod != LDAP_AUTH_SASL ) {\n\t\t\t\tfprintf( stderr, \"%s: incompatible previous \"\n\t\t\t\t\t\"authentication choice\\n\",\n\t\t\t\t\tprog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tauthmethod = LDAP_AUTH_SASL;\n\t\t\tsasl_flags = LDAP_SASL_INTERACTIVE;\n\t\t\tbreak;\n#else\n\t\t\tfprintf( stderr, \"%s: was not compiled with SASL support\\n\",\n\t\t\t\tprog );\n\t\t\texit( EXIT_FAILURE );\n#endif\n\t\tcase 'M':\n\t\t\t\n\t\t\tmanageDSAit++;\n\t\t\tbreak;\n\t\tcase 'n':\t\n\t\t\tdont++;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tnocanon++;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tcontrol = optarg;\n\t\t\tif ( (cvalue = strchr( control, '=' )) != NULL ) {\n\t\t\t\t*cvalue++ = '\\0';\n\t\t\t}\n\t\t\tfor ( next=control; *next; next++ ) {\n\t\t\t\tif ( *next == '-' ) {\n\t\t\t\t\t*next = '_';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( strcasecmp( control, \"nettimeout\" ) == 0 ) {\n\t\t\t\tif( nettimeout.tv_sec != -1 ) {\n\t\t\t\t\tfprintf( stderr, \"nettimeout option previously specified\\n\");\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tif( cvalue == NULL || cvalue[0] == '\\0' ) {\n\t\t\t\t\tfprintf( stderr, \"nettimeout: option value expected\\n\" );\n\t\t\t\t\tusage();\n\t\t\t\t}\n\t\t \t\tif ( strcasecmp( cvalue, \"none\" ) == 0 ) {\n\t\t \t\t\tnettimeout.tv_sec = 0;\n\t\t \t\t} else if ( strcasecmp( cvalue, \"max\" ) == 0 ) {\n\t\t \t\t\tnettimeout.tv_sec = LDAP_MAXINT;\n\t\t \t\t} else {\n\t\t \t\t\tival = strtol( cvalue, &next, 10 );\n\t\t \t\t\tif ( next == NULL || next[0] != '\\0' ) {\n\t\t \t\t\t\tfprintf( stderr,\n\t\t \t\t\t\t\t_(\"Unable to parse network timeout \\\"%s\\\"\\n\"), cvalue );\n\t\t \t\t\t\texit( EXIT_FAILURE );\n\t\t \t\t\t}\n\t\t \t\t\tnettimeout.tv_sec = ival;\n\t\t \t\t}\n\t\t \t\tif( nettimeout.tv_sec < 0 || nettimeout.tv_sec > LDAP_MAXINT ) {\n\t\t \t\t\tfprintf( stderr, _(\"%s: invalid network timeout (%ld) specified\\n\"),\n\t\t \t\t\t\tprog, (long)nettimeout.tv_sec );\n\t \t\t\t\texit( EXIT_FAILURE );\n \t\t\t\t}\n\n\t\t\t} else if ( strcasecmp( control, \"ldif_wrap\" ) == 0 ) {\n\t\t\t\tif ( cvalue == 0 ) {\n\t\t\t\t\tldif_wrap = LDIF_LINE_WIDTH;\n\n\t\t\t\t} else if ( strcasecmp( cvalue, \"no\" ) == 0 ) {\n\t\t\t\t\tldif_wrap = LDIF_LINE_WIDTH_MAX;\n\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int u;\n\t\t\t\t\tif ( lutil_atou( &u, cvalue ) ) {\n\t\t\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\t\t_(\"Unable to parse ldif_wrap=\\\"%s\\\"\\n\"), cvalue );\n\t\t \t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t\t}\n\t\t\t\t\tldif_wrap = (ber_len_t)u;\n\t\t\t\t}\n\n\t\t\t} else if ( ldap_pvt_conf_option( control, cvalue, 1 ) ) {\n\t\t\t\tfprintf( stderr, \"Invalid general option name: %s\\n\",\n\t\t\t\t\tcontrol );\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'O':\n#ifdef HAVE_CYRUS_SASL\n\t\t\tif( sasl_secprops != NULL ) {\n\t\t\t\tfprintf( stderr, \"%s: -O previously specified\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tif( authmethod != -1 && authmethod != LDAP_AUTH_SASL ) {\n\t\t\t\tfprintf( stderr, \"%s: incompatible previous \"\n\t\t\t\t\t\"authentication choice\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tauthmethod = LDAP_AUTH_SASL;\n\t\t\tsasl_secprops = optarg;\n#else\n\t\t\tfprintf( stderr, \"%s: not compiled with SASL support\\n\", prog );\n\t\t\texit( EXIT_FAILURE );\n#endif\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tival = strtol( optarg, &next, 10 );\n\t\t\tif ( next == NULL || next[0] != '\\0' ) {\n\t\t\t\tfprintf( stderr, \"%s: unable to parse protocol version \\\"%s\\\"\\n\", prog, optarg );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tswitch( ival ) {\n\t\t\tcase 2:\n\t\t\t\tif( protocol == LDAP_VERSION3 ) {\n\t\t\t\t\tfprintf( stderr, \"%s: -P 2 incompatible with version %d\\n\",\n\t\t\t\t\t\tprog, protocol );\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tprotocol = LDAP_VERSION2;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif( protocol == LDAP_VERSION2 ) {\n\t\t\t\t\tfprintf( stderr, \"%s: -P 2 incompatible with version %d\\n\",\n\t\t\t\t\t\tprog, protocol );\n\t\t\t\t\texit( EXIT_FAILURE );\n\t\t\t\t}\n\t\t\t\tprotocol = LDAP_VERSION3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf( stderr, \"%s: protocol version should be 2 or 3\\n\",\n\t\t\t\t\tprog );\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Q':\n#ifdef HAVE_CYRUS_SASL\n\t\t\tif( authmethod != -1 && authmethod != LDAP_AUTH_SASL ) {\n\t\t\t\tfprintf( stderr, \"%s: incompatible previous \"\n\t\t\t\t\t\"authentication choice\\n\",\n\t\t\t\t\tprog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tauthmethod = LDAP_AUTH_SASL;\n\t\t\tsasl_flags = LDAP_SASL_QUIET;\n\t\t\tbreak;\n#else\n\t\t\tfprintf( stderr, \"%s: not compiled with SASL support\\n\",\n\t\t\t\tprog );\n\t\t\texit( EXIT_FAILURE );\n#endif\n\t\tcase 'R':\n#ifdef HAVE_CYRUS_SASL\n\t\t\tif( sasl_realm != NULL ) {\n\t\t\t\tfprintf( stderr, \"%s: -R previously specified\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tif( authmethod != -1 && authmethod != LDAP_AUTH_SASL ) {\n\t\t\t\tfprintf( stderr, \"%s: incompatible previous \"\n\t\t\t\t\t\"authentication choice\\n\",\n\t\t\t\t\tprog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tauthmethod = LDAP_AUTH_SASL;\n\t\t\tsasl_realm = optarg;\n#else\n\t\t\tfprintf( stderr, \"%s: not compiled with SASL support\\n\",\n\t\t\t\tprog );\n\t\t\texit( EXIT_FAILURE );\n#endif\n\t\t\tbreak;\n\t\tcase 'U':\n#ifdef HAVE_CYRUS_SASL\n\t\t\tif( sasl_authc_id != NULL ) {\n\t\t\t\tfprintf( stderr, \"%s: -U previously specified\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tif( authmethod != -1 && authmethod != LDAP_AUTH_SASL ) {\n\t\t\t\tfprintf( stderr, \"%s: incompatible previous \"\n\t\t\t\t\t\"authentication choice\\n\",\n\t\t\t\t\tprog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tauthmethod = LDAP_AUTH_SASL;\n\t\t\tsasl_authc_id = optarg;\n#else\n\t\t\tfprintf( stderr, \"%s: not compiled with SASL support\\n\",\n\t\t\t\tprog );\n\t\t\texit( EXIT_FAILURE );\n#endif\n\t\t\tbreak;\n\t\tcase 'v':\t\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\tcase 'V':\t\n\t\t\tversion++;\n\t\t\tbreak;\n\t\tcase 'w':\t\n\t\t\tpasswd.bv_val = ber_strdup( optarg );\n\t\t\t{\n\t\t\t\tchar* p;\n\n\t\t\t\tfor( p = optarg; *p != '\\0'; p++ ) {\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tpasswd.bv_len = strlen( passwd.bv_val );\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twant_bindpw++;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tpw_file = optarg;\n\t\t\tbreak;\n\t\tcase 'Y':\n#ifdef HAVE_CYRUS_SASL\n\t\t\tif( sasl_mech != NULL ) {\n\t\t\t\tfprintf( stderr, \"%s: -Y previously specified\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tif( authmethod != -1 && authmethod != LDAP_AUTH_SASL ) {\n\t\t\t\tfprintf( stderr,\n\t\t\t\t\t\"%s: incompatible with authentication choice\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tauthmethod = LDAP_AUTH_SASL;\n\t\t\tsasl_mech = optarg;\n#else\n\t\t\tfprintf( stderr, \"%s: not compiled with SASL support\\n\", prog );\n\t\t\texit( EXIT_FAILURE );\n#endif\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif( authmethod != -1 && authmethod != LDAP_AUTH_SIMPLE ) {\n\t\t\t\tfprintf( stderr, \"%s: incompatible with previous \"\n\t\t\t\t\t\"authentication choice\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tauthmethod = LDAP_AUTH_SIMPLE;\n\t\t\tbreak;\n\t\tcase 'X':\n#ifdef HAVE_CYRUS_SASL\n\t\t\tif( sasl_authz_id != NULL ) {\n\t\t\t\tfprintf( stderr, \"%s: -X previously specified\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tif( authmethod != -1 && authmethod != LDAP_AUTH_SASL ) {\n\t\t\t\tfprintf( stderr, \"%s: -X incompatible with \"\n\t\t\t\t\t\"authentication choice\\n\", prog );\n\t\t\t\texit( EXIT_FAILURE );\n\t\t\t}\n\t\t\tauthmethod = LDAP_AUTH_SASL;\n\t\t\tsasl_authz_id = optarg;\n#else\n\t\t\tfprintf( stderr, \"%s: not compiled with SASL support\\n\", prog );\n\t\t\texit( EXIT_FAILURE );\n#endif\n\t\t\tbreak;\n\t\tcase 'Z':\n#ifdef HAVE_TLS\n\t\t\tuse_tls++;\n#else\n\t\t\tfprintf( stderr, \"%s: not compiled with TLS support\\n\", prog );\n\t\t\texit( EXIT_FAILURE );\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif( handle_private_option( i ) ) break;\n\t\t\tfprintf( stderr, \"%s: unrecognized option -%c\\n\",\n\t\t\t\tprog, optopt );\n\t\t\tusage();\n\t\t}\n\t}\n\n\t{\n\t\t\n\t\tLDAPAPIInfo api;\n\t\tapi.ldapai_info_version = LDAP_API_INFO_VERSION;\n\n\t\tif ( ldap_get_option(NULL, LDAP_OPT_API_INFO, &api)\n\t\t\t!= LDAP_OPT_SUCCESS )\n\t\t{\n\t\t\tfprintf( stderr, \"%s: ldap_get_option(API_INFO) failed\\n\", prog );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\n\t\tif (api.ldapai_info_version != LDAP_API_INFO_VERSION) {\n\t\t\tfprintf( stderr, \"LDAP APIInfo version mismatch: \"\n\t\t\t\t\"library %d, header %d\\n\",\n\t\t\t\tapi.ldapai_info_version, LDAP_API_INFO_VERSION );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\n\t\tif( api.ldapai_api_version != LDAP_API_VERSION ) {\n\t\t\tfprintf( stderr, \"LDAP API version mismatch: \"\n\t\t\t\t\"library %d, header %d\\n\",\n\t\t\t\tapi.ldapai_api_version, LDAP_API_VERSION );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\n\t\tif( strcmp(api.ldapai_vendor_name, LDAP_VENDOR_NAME ) != 0 ) {\n\t\t\tfprintf( stderr, \"LDAP vendor name mismatch: \"\n\t\t\t\t\"library %s, header %s\\n\",\n\t\t\t\tapi.ldapai_vendor_name, LDAP_VENDOR_NAME );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\n\t\tif( api.ldapai_vendor_version != LDAP_VENDOR_VERSION ) {\n\t\t\tfprintf( stderr, \"LDAP vendor version mismatch: \"\n\t\t\t\t\"library %d, header %d\\n\",\n\t\t\t\tapi.ldapai_vendor_version, LDAP_VENDOR_VERSION );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n\n\t\tif (version) {\n\t\t\tfprintf( stderr, \"%s: %s\\t(LDAP library: %s %d)\\n\",\n\t\t\t\tprog, __Version,\n\t\t\t\tLDAP_VENDOR_NAME, LDAP_VENDOR_VERSION );\n\t\t\tif (version > 1) exit( EXIT_SUCCESS );\n\t\t}\n\n\t\tldap_memfree( api.ldapai_vendor_name );\n\t\tber_memvfree( (void **)api.ldapai_extensions );\n\t}\n\n\tif (protocol == -1)\n\t\tprotocol = LDAP_VERSION3;\n\n\tif (authmethod == -1 && protocol > LDAP_VERSION2) {\n#ifdef HAVE_CYRUS_SASL\n\t\tif ( binddn != NULL ) {\n\t\t\tauthmethod = LDAP_AUTH_SIMPLE;\n\t\t} else {\n\t\t\tauthmethod = LDAP_AUTH_SASL;\n\t\t}\n#else\n\t\tauthmethod = LDAP_AUTH_SIMPLE;\n#endif\n\t}\n\n\tif( protocol == LDAP_VERSION2 ) {\n\t\tif( assertctl || authzid || manageDIT || manageDSAit ||\n#ifdef LDAP_CONTROL_OBSOLETE_PROXY_AUTHZ\n\t\t\tproxydn ||\n#endif \n#ifdef LDAP_CONTROL_X_CHAINING_BEHAVIOR\n\t\t\tchaining ||\n#endif\n#ifdef LDAP_CONTROL_X_SESSION_TRACKING\n\t\t\tsessionTracking ||\n#endif \n\t\t\tnoop || ppolicy || preread || postread )\n\t\t{\n\t\t\tfprintf( stderr, \"%s: -e/-M incompatible with LDAPv2\\n\", prog );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n#ifdef HAVE_TLS\n\t\tif( use_tls ) {\n\t\t\tfprintf( stderr, \"%s: -Z incompatible with LDAPv2\\n\", prog );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n#endif\n#ifdef HAVE_CYRUS_SASL\n\t\tif( authmethod == LDAP_AUTH_SASL ) {\n\t\t\tfprintf( stderr, \"%s: -[IOQRUXY] incompatible with LDAPv2\\n\",\n\t\t\t\tprog );\n\t\t\texit( EXIT_FAILURE );\n\t\t}\n#endif\n\t}\n\n\tif ( ( pw_file || want_bindpw ) && !BER_BVISNULL( &passwd ) ) {\n\t\tfprintf( stderr, \"%s: -%c incompatible with -w\\n\",\n\t\t\tprog, ( pw_file ? 'y' : 'W' ) );\n\t\texit( EXIT_FAILURE );\n\t}\n}"
            }
        ],
        "Links": [
            "https://github.com/openldap/openldap/tree/519e0c94c9f3804813f691de487283ad7586f510/libraries/liblber/memory.c#L653",
            "https://github.com/openldap/openldap/tree/519e0c94c9f3804813f691de487283ad7586f510/clients/tools/common.c#L982"
        ]
    },
    {
        "Function Path": "<\\treturn ber_strdup_x( s, NULL );, ber_strdup> --> <ber_strdup( urlstr ), ldif_open_url>",
        "Path": "<Lines: 4, Source: `\\treturn ber_strdup_x( s, NULL );`,  Function: `ber_strdup`, Status: Unknown. File: ../benchmark/C/openldap/libraries/liblber/memory.c> --> <Lines: 7-31, 32-40, 41-45, 54, Source: `ber_strdup( urlstr )`,  Function: `ldif_open_url`, Status: Bug. File: ../benchmark/C/openldap/libraries/libldap/fetch.c>",
        "Explanation": "The return value of ber_strdup_x is returned to the caller of function ber_strdup.\\nThe NULL value from ber_strdup at line 32 propagates to pointer `p`, then to pointer `s` through strchr at line 37, and is dereferenced at line 38 without NULL check.",
        "Model": "Claude-3.5, Deepseek-R1",
        "Is Reproduce": "No",
        "Functions": [
            {
                "Function": "ber_strdup",
                "Function Body": "char *\nber_strdup( LDAP_CONST char *s )\n{\n\treturn ber_strdup_x( s, NULL );\n}"
            },
            {
                "Function": "ldif_open_url",
                "Function Body": "FILE *\nldif_open_url(\n\tLDAP_CONST char *urlstr )\n{\n\tFILE *url;\n\n\tif( strncasecmp( \"file:\", urlstr, sizeof(\"file:\")-1 ) == 0 ) {\n\t\tchar *p;\n\t\turlstr += sizeof(\"file:\")-1;\n\n\t\t\n\t\tif ( urlstr[0] == '/' && urlstr[1] == '/' ) {\n\t\t\turlstr += 2;\n\t\t\t\n\n\n\n\t\t\tif ( urlstr[0] != '/' ) {\n#ifdef _WIN32\n\t\t\t\t\n\t\t\t\tif ( urlstr[1] != ':' )\n#endif\n\t\t\t\treturn NULL;\n\t\t\t}\n#ifdef _WIN32\n\t\t\t\n\t\t\tif ( urlstr[2] == ':' )\n\t\t\t\turlstr++;\n#endif\n\t\t}\n\n\t\tp = ber_strdup( urlstr );\n\n\t\t\n\t\tif ( LDAP_DIRSEP[0] != '/' ) {\n\t\t\tchar *s = p;\n\t\t\twhile (( s = strchr( s, '/' )))\n\t\t\t\t*s++ = LDAP_DIRSEP[0];\n\t\t}\n\n\t\tldap_pvt_hex_unescape( p );\n\n\t\turl = fopen( p, \"rb\" );\n\n\t\tber_memfree( p );\n\t} else {\n#ifdef HAVE_FETCH\n\t\turl = fetchGetURL( (char*) urlstr, \"\" );\n#else\n\t\turl = NULL;\n#endif\n\t}\n\treturn url;\n}"
            }
        ],
        "Links": [
            "https://github.com/openldap/openldap/tree/519e0c94c9f3804813f691de487283ad7586f510/libraries/liblber/memory.c#L653",
            "https://github.com/openldap/openldap/tree/519e0c94c9f3804813f691de487283ad7586f510/libraries/libldap/fetch.c#L71"
        ]
    }
]